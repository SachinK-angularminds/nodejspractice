class HANDLER {
	#allHandlers;

	#paramSkeletons;

	#BAD_ROUTE;

	static #FORWARD_SLASH = "/";

	static #PARAM_INDICATOR = "/:";

	static #OPTIONAL_PARAM_INDICATOR = "/?:";

	constructor(ROUTES, BAD_ROUTE) {
		if(!Array.isArray(ROUTES)) {
			throw new Error("Expected an \"array\" as the first argument");
		} else if(!this.#compareType("function", BAD_ROUTE)) {
			throw new Error("Expected a \"function\" as the second argument for handling wild-card routes");
		}

		this.#BAD_ROUTE = (...args) => BAD_ROUTE(...args);

		this.#setAllHandlers(this.#getAllHandlers(ROUTES));
	}

	static #removeQuery(url) {
		return url.split("?")[0];
	}

	static #parseQuery(url) {
		return (url.split("?")[1] || "").split("&").filter(x => x != "").reduce((acc, x) => ({...acc, [x.split("=")[0]]: x.split("=")[1]}), {});
	}

  static #parseBody(event) {
		return new Promise((resolve, reject) => {
			let b = Buffer.alloc(0);
			event.on("data", chunk => b = Buffer.concat([b, chunk]));
			event.on("end", () => {
				try {
					resolve(JSON.parse(b.toString()));
				} catch(error) {
					resolve(b);
				}
			});
			event.on("error", (error) => {
				resolve(Buffer.alloc(0));
			});
		});
	}

	get handlerFn() {
		return async (req, res) => {
			if(["/favicon.ico", "/.well-known/appspecific/com.chrome.devtools.json"].includes(req.url)) return res.end(null);
			req.query = HANDLER.#parseQuery(req.url || "");
			req.params = {};
			req.body = await HANDLER.#parseBody(req);
			this.#handleRoutes(req.url, req, res);
		}
	}

	patch(cb) {
		if(!this.#compareType("function", cb)) throw new Error(`Expected a "function" as argument for "patch" function`);
		Object.keys(this.#allHandlers).forEach(key => {
			this.#allHandlers[key].handlersArray.unshift(cb);
		});
		return this;
	}

	#handleRoutes(url, req, res) {
	  const [HANDLER_ARRAY, PARAMS_INFO] = (this.#getValidHandlers(url, req.method) || []);
	  if((HANDLER_ARRAY ?? []).length == 0) return this.#BAD_ROUTE(req, res);
	  req["params"] = PARAMS_INFO ?? {};
	  this.#callHandlers(HANDLER_ARRAY, 0, req, res);
	}

	#callHandlers(arr, i, req, res) {
		arr[i](req, res, () => i+1 == arr.length ? null : this.#callHandlers(arr, i+1, req, res));
	}

	#getValidHandlers(path, method) {
		path = method.toLowerCase() + path;
		path = HANDLER.#removeQuery(path);
		path = path.replace(new RegExp(HANDLER.#PARAM_INDICATOR, "g"), "");
		path = path.replace(new RegExp(HANDLER.#OPTIONAL_PARAM_INDICATOR, "g"), "");
		path = HANDLER.#FORWARD_SLASH + path.split(HANDLER.#FORWARD_SLASH).filter(value => value.trim() != "").join(HANDLER.#FORWARD_SLASH);

		path = [this.#allHandlers[path], path];
		if(path[0]) return [path[0].handlersArray, {}];

		path = path[1];

		path = path.split(HANDLER.#FORWARD_SLASH).filter(item => item.trim() != "");
		const ORIGINAL_PATH = [...path];
		const REQUIRED_SKELETONS = this.#fetchParamHandlers(path.length);
		for(let i of path.keys()) {
			for(let j = 0; j < REQUIRED_SKELETONS.length; j++) {
				if(REQUIRED_SKELETONS[j][i] == path[i]) {
					break;
				} else if([HANDLER.#PARAM_INDICATOR, HANDLER.#OPTIONAL_PARAM_INDICATOR].includes(HANDLER.#FORWARD_SLASH + REQUIRED_SKELETONS[j][i])) {
						continue;
				} else {
					REQUIRED_SKELETONS.splice(j--, 1);
				}
			}
		}

		if(REQUIRED_SKELETONS.length == 0) return [[], null];
		if(REQUIRED_SKELETONS.length == 1) path = HANDLER.#FORWARD_SLASH + REQUIRED_SKELETONS[0].join(HANDLER.#FORWARD_SLASH);
		else {
			path = HANDLER.#FORWARD_SLASH + REQUIRED_SKELETONS.map(value => {
				return {
					value: value,
					score: value.reduce((acc, x) => acc + ([HANDLER.#PARAM_INDICATOR, HANDLER.#OPTIONAL_PARAM_INDICATOR].includes(HANDLER.#FORWARD_SLASH + x) ? -1 : 1), 0)
				};
			}).sort((a, b) => b.score-a.score)[0].value.join(HANDLER.#FORWARD_SLASH);
		}

		return [
			this.#allHandlers[this.#paramSkeletons[path]]?.handlersArray,
			this.#paramSkeletons[path].split(HANDLER.#FORWARD_SLASH).filter(value => value.trim() != 0).reduce((acc, x, i, arr) => {
				if(HANDLER.#PARAM_INDICATOR == HANDLER.#FORWARD_SLASH + x[0]) {
					if(ORIGINAL_PATH[i]) acc[x.substring(1)] = ORIGINAL_PATH[i];
				}
				else if(HANDLER.#OPTIONAL_PARAM_INDICATOR == HANDLER.#FORWARD_SLASH + x.substring(0, 2)) {
					if(ORIGINAL_PATH[i]) acc[x.substring(2)] = ORIGINAL_PATH[i];
				}

				return acc;
			}, {})
		];
	}

	#fetchParamHandlers(sections) {
		return Object.keys(this.#paramSkeletons).filter(value => {
			return value.split(HANDLER.#FORWARD_SLASH).filter(value => value.trim() != 0).length == sections;
		}).map(value => value.split(HANDLER.#FORWARD_SLASH).filter(value => value.trim() != 0));
	}

	#setAllHandlers(allHandlers) {
		this.#allHandlers = allHandlers;
		let PARAM_HANDLERS = {}, temp;
		this.#paramSkeletons = {};
		for(let [key] of Object.entries(allHandlers)) {
			if(key.includes(HANDLER.#PARAM_INDICATOR) || key.includes(HANDLER.#OPTIONAL_PARAM_INDICATOR)) {
				temp = "";
				key.split(HANDLER.#FORWARD_SLASH).filter(item => item.trim() != "").forEach(item => {
					if(item[0] == HANDLER.#PARAM_INDICATOR[1]) {
						if(Array.isArray(temp)) {
							temp = temp.map(value => value + (HANDLER.#FORWARD_SLASH + item[0]));
						} else {
							temp += HANDLER.#FORWARD_SLASH + item[0];
						}
					}
					else if(item.substring(0, 2) == HANDLER.#OPTIONAL_PARAM_INDICATOR.substring(1)) {
						if(Array.isArray(temp)) {
							for(let i = 0; i < Math.ceil(temp.length/2); i++) {
								temp.push(temp[i]+ HANDLER.#FORWARD_SLASH + item.substring(0, 2));
							}
						} else {
							temp = [temp + HANDLER.#FORWARD_SLASH + item.substring(0, 2), temp];
						}
					}
					else {
						if(Array.isArray(temp)) {
							temp = temp.map(value => value + (HANDLER.#FORWARD_SLASH + item));
						} else {
							temp += HANDLER.#FORWARD_SLASH + item;
						}
					}
				});
				if(Array.isArray(temp)) {
					temp.forEach(value => this.#paramSkeletons[value] = key);
				} else {
					this.#paramSkeletons[temp] = key;
				}
			}
		}
	}

	#getAllHandlers(ROUTES, parentRoute = "", oldHandlers = {}, oldMiddlewares = []) {
		let HANDLERS = {}, temp;
		for(let route of ROUTES) {
			temp = this.#isValid({...route, parentRoute: parentRoute, multi: Boolean(route?.multi)});
			if(!temp[0]) throw new Error(temp[1]);

			temp = parentRoute;
			if(temp == HANDLER.#FORWARD_SLASH) temp = "";
			temp += route.path == HANDLER.#FORWARD_SLASH ? "" : route.path
			temp = temp == "" ? HANDLER.#FORWARD_SLASH : temp;

			if((route.subRoutes || []).length == 0 && temp == HANDLER.#FORWARD_SLASH) temp = "";

			const METHOD_TYPES = ["get", "post", "put", "patch", "delete"];
			let flag = true;
			for(let type of METHOD_TYPES) {
				if(Object.hasOwn(route, type) && route[type].length != 0) {
					flag = false;
					HANDLERS[HANDLER.#FORWARD_SLASH+type+temp] = {
						path: HANDLER.#FORWARD_SLASH+type+temp,
						handlersArray: [...(oldHandlers[HANDLER.#FORWARD_SLASH+type+temp]?.handlersArray || []), ...oldMiddlewares,  ...(route["middlewares"] || []), ...(route[type] || [])]
					};
				}
			}

			if((route.subRoutes || []).length != 0) {
				HANDLERS = {
					...HANDLERS,
					...this.#getAllHandlers(route.subRoutes, temp, HANDLERS, flag ? [...oldMiddlewares, ...(route.middlewares || [])] : [])
				};
			}
		}
		return HANDLERS;
	}

	#isValid = (route) => {
		if(route == undefined || route == null || Array.isArray(route) || (typeof route).toLowerCase() != "object") return [false, "A route must be an object"];
		else if(!this.#compareType("string", route.path)) return [false, `"${route.parentRoute+route.path}" route's "path" property must be of type "string"`];
		else if(route.path[0] != HANDLER.#FORWARD_SLASH) return [false, `"${route.parentRoute+route.path}" route's "path" property must start with "${HANDLER.#FORWARD_SLASH}"`];
		else if(!route.multi && route.path.substring(1).includes(HANDLER.#FORWARD_SLASH)) return [false, `"${route.parentRoute+route.path}" route's "path" property must contain only one "${HANDLER.#FORWARD_SLASH}" and that to be present at starting`];

		const KEYS = ["middlewares", "get", "post", "put", "patch", "delete"];

		let flag = true, flag2 = true, flag3 = false;
		for(let key of KEYS) {
			if(Object.hasOwn(route, key)) {
				flag = false;
				if(!Array.isArray(route[key])) return [false, `"${route.parentRoute+route.path}" route's "${key}" property must be of type "array"`];
				if(!flag3 && !KEYS.slice(0, 1).includes(key) && Object.hasOwn(route, key) && route[key].length != 0) flag3 = true;
				for(let i of route[key]) {
					if(!this.#compareType("function", i)) return [false, `each item in "${route.parentRoute+route.path}" route's "${key}" property must be of type "function"`];
					flag2 = false;
				}
			}
		}

		if(Object.hasOwn(route, "subRoutes")) {
			if(!Array.isArray(route.subRoutes)) return [false, `"${route.parentRoute+route.path}" route's "subRoutes" property must of type "array"`];
			else if(flag3) return [false, `"${route.parentRoute+route.path}" route contains "subRoutes" property, so must not contain any property among these properties : ${KEYS.slice(1).join(", ")}`];
		}

		else if(!flag3) {
			return [false, `"${route.parentRoute+route.path}" route must contain atleast one property among these properties : ${KEYS.slice(1).join(", ")}`];
		}
		
		else if((route.subRoutes || []).length == 0) {
			if(flag2) return [false, `"${route.parentRoute+route.path}" route must contain atleast one handler function among any one of these properties : ${KEYS.join(", ")}`];
			else if(flag) return [false, `"${route.parentRoute+route.path}" route must contain atleast one of these properties : ${KEYS.join(", ")}`];
		}
		
		return [true];
	}

	#compareType(type, ...args) {
		let i = 0;
		while(i < args.length) {
			if(type != (typeof args[i]).toLowerCase()) return false;
			i++;
		}

		return true;
	}
}

module.exports = HANDLER
